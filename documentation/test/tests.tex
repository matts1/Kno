\subsection{Test Report With Test Data}
\paragraph{}
As my website will be large, it will require a lot of testing. However, when I change one bit of the code, all of the code will need testing, as things may break when interacting with each other. For that reason, I am going to use TDD (test driven development). In test driven development, you write your tests before you write your code. Also, when you find a bug, instead of trying to fix it, the first thing you do is to create a test case which fails. It is used in most large businesses that do software development, as it can test their whole codebase (which could be very large) in a short amount of time.

\paragraph{}
However, some parts of the website are more practical than others to test. In particular, it is important to test code that will get changed often, or will be affected by the changing of other bits of code. On the other hand, if a piece of code is unlikely to change after you code it up the first time, it may not be necessary to write automated tests for it, and simply manually test it when you change it. In the end, for each section of code, I weighed up the difficulty to test against how useful testing it would be. These sections were:
\begin{itemize}
	\item The models, which do all the processing and backend which performs operations on the data
	\item The request handlers for each page, which get the data from html forms and send it to the backend, and get the data about the models and send it to the template, outputting the results of the template. These can be thought of as a way of communicating between models and templates.
	\item The templates, which output html based off the input from the request handlers. The html is dynamic, but is usually similar.
	\item The javascript, which handles client side execution of code. This is what makes the forms submit without reloading the page, along with many other things.
\end{itemize}

\subsubsection{Models}
The models have functions attached to them such as authentication, registration, and login. Because some of these functions change, such as if I add a new piece of data about a person (eg. When I added in first name and surname, I had to change the registration to take 2 new parameters), it was necessary to write automated tests for it. They also interact with each other a lot. For example, a course has to have users attached to it, so if a course changes, it is quite possible that the user will have to change. It is also extremely easy to test models, as you just call functions and check whether they return None (usually meaning no error) or an error message. For this reason, models were extremely heavily tested.

\subsubsection{Request Handlers}
Because the request handlers are the communication between the template and the models, they only need to change when either of those get changed. Bugs in this can easily be found by loading the appropriate webpage on the site, however, as there is usually little, if any, control structures in them, so loading the page once tests it all. When I change the template, I have to reload the page in order to see the changes, so it is unnecessary to test them in that case. When I change the internals of the models, it does not affect the request handlers, because all I am doing is calling those functions. The only time when changing the models would affect the request handler is when changing the parameters of a function, which, in the large majority of cases, happens when adding new data that is submitted via forms (in which case you would be reloading the function anyway). For these reasons, it is not particularly useful to test the request handlers. It is also extremely hard to test them automatically as they simply output the html that the template outputs (and given that the HTML changes extremely rapidly, it is hard to see if it is correct).

\subsubsection{Templates}
The templates usually require a small amount of testing on the actual website to check if they are correct. The only dynamic part of the templates is usually just outputting data straight from the models (because you never do processing in the template - only formatting). Because they change regularly, but the dynamic content changes rarely, it is both extremely hard and unnecessary to test the templates.

\subsubsection{Javascript}
Javascript's sole purpose is usually to, on a certain event (eg. hitting submit on a form), change the HTML of the page. It is also extremely hard to test, as the only way I currently have of running it is within a web browser. Because it happens on a certain event, if I keep my formatting of things such as forms consistent, such as making the submit button always have a certain class, then it becomes extremely easy to make the event the same. By using template macros for forms (and other things that I want to keep consistent), it becomes trivial to have Javascript which works across the whole site and does not change when your html changes. For these reasons, I decided not to test javascript automatically.

\todo{Input some code from the testing suite, show my manual testing methods}